(configure :bitwidth 2 :produce-cores false :solver SAT4J :max-solutions 1 :verbosity 6)

(univ 20)

(r0 [{(16 19)(17 18)(18 17)(19 16)}])

(r1 [{(16)}])
(r2 [{(16)(17)(18)(19)}])
(r3 [{(17)(18)(19)}])

; This one is always true with the above bounds, have already checked.
;(f0 (= r3 (- r2 r1)))
;(assert f0)

;------ This one produces sat
 (f1 (all ([v1 : r3]) (all ([v2 : (- (- r2 r1) v1)])		(! (= (# (. v1 r0)) (# (. v2 r0)))))))
; (f1 (all ([v1 : r3]) (all ([v2 : (- (- r3 v1) (- r3 r2))])	(! (= (# (. v1 r0)) (# (. v2 r0)))))))
 (assert f1)
;
;------ this one, unsat.
;------ so this is a stronger constraint, I'd like to see why and how.
;------ interesting. if i subtract v1 AGAIN, it now works. Even though that clearly
;------ shouldn't make a difference.
; (f2 (all ([v1 : r3]) (all ([v2 : (- (- r3 v1) v1)]) 	(! (= (# (. v1 r0)) (# (. v2 r0)))))))
; (f2 (all ([v1 : r3]) (all ([v2 : (- r3 v1)]) 		(! (= (# (. v1 r0)) (# (. v2 r0)))))))
; (assert f2)

(solve)




; OK so I should expect it to break in a DIFFERENT way on something like (- (- r3 v1) (- r3 r2))
; let's try it.
